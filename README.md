# Техническое задание проекта №3. Конструктор обеда

Время практики! Надеемся, вы уже перекусили, ведь в этот раз вам предстоит помочь ресторану с планированием меню бизнес-ланчей.
Повара в ресторане умеют готовить много вкусных блюд. Но скомбинировать их между собой — непростая задача, которая отнимает много времени. Так что вам поручили разработать программу — генератор комбо-обедов. С ней сотрудникам ресторана будет проще составлять разнообразные комбинации. Можно приступать!

## Сценарии использования

У приложения будет два основных сценария использования. Работа с ним должна происходить так:

1. Сначала администрация ресторана добавляет в программу доступные для заказа блюда. Для этого пользователь вводит тип блюда (например, **Первое**, **Второе**, **Напиток**) и само название. Допустим, он может добавить блюдо **Солянка мясная** с типом **Второе**.

2. Когда доступные блюда сохранены, администрация ресторана переходит к генерации комбинаций для бизнес-ланча. Для этого пользователь указывает набор типов блюд, которые должны входить в бизнес-ланч. Например, **Первое**, **Второе** и **Напиток**. В ответ программа выводит одну или несколько возможных комбинаций из блюд этих типов. После одобрения администрацией ресторан сможет использовать получившиеся комбинации в меню бизнес-ланчей.

## Требования к интерфейсу

Перейдём к планированию реализации. Склонируйте [шаблон проекта с GitHub](https://github.com/praktikum-java/dinner-constructor).  Как и в предыдущих заданиях, приложение будет иметь консольный интерфейс. В этот раз мы уже подготовили для вас код интерфейса — вам остаётся реализовать только логику.

Опишем, как должна работать каждая из трёх команд приложения:

* 1 — добавление нового блюда. Программа поочерёдно запрашивает у пользователя тип и название блюда и сохраняет их. Пользователь может ввести любую строку в качестве типа или названия.

**Пример**: в качестве типа блюда пользователь ввёл **Напиток**, а в качестве названия — **Сок яблочный**.

![Добавление нового блюда](https://github.com/SkvortsovEvg/yandex_sprint03_final/blob/master/images/readme/pic_001.png "Текст 001")

* 2 — генерация комбинаций блюд. Приложение запрашивает у пользователя количество комбинаций, а затем список типов блюд, которые должны входить в эти комбинации. Программа генерирует несколько вариантов для одного и того же набора типов блюд. Условия:

* каждый тип вводится с новой строки;
* комбинации должны быть составлены из существующих блюд этих типов случайным образом;
* количество типов блюд в комбинации не ограничено, при этом типы могут повторяться;
* для завершения ввода пользователь должен ещё раз нажать **Enter**;
* если пользователь ввёл несуществующий тип, программа должна вывести предупреждающее сообщение и предложить ввести другой тип.

**Пример**: пользователь запросил две комбинации для набора **Напиток**, **Гарнир**, **Мясо**. Тогда программа может вывести следующее: **\[Морс облепиховый, Гречка, Котлета пожарская\]** и **\[Сок яблочный, Картофельное пюре, Поджарка мясная\]**.

![Генерация новых блюд](https://github.com/SkvortsovEvg/yandex_sprint03_final/blob/master/images/readme/pic_002.png "Текст 002")

* 3 — выход из программы. При выборе этой команды программа должна завершить работу.

## Техническая реализация

Перейдём к техническим деталям реализации. В подготовленном нами шаблоне уже есть два класса:

* класс _Main_, в котором будет расположен код консольного интерфейса;
* класс _DinnerConstructor_, который будет содержать основную логику по хранению блюд и генерации комбинаций.

Классы _Main_ и _DinnerConstructor_ — обязательные. Если будет желание, вы также можете структурировать код по-другому и реализовать дополнительные классы.

Важное условие: весь код, который взаимодействует с пользователем, должен находиться в классе _Main_. Это значит, что вы не должны использовать объекты класса _Scanner_ внутри _DinnerConstructor_. Такой подход позволит чётко отделить интерфейс программы от её логики. Затем вы сможете при необходимости независимо изменять то или другое.

Для генерации комбинаций блюд используйте класс _Random_. Вам нужно создать новый экземпляр этого класса — достаточно сделать это один раз на всё приложение. В дальнейшем вы сможете использовать методы этого экземпляра для генерации случайных значений внутри программы.

Подумайте, какая структура данных лучше всего подойдёт для хранения списка доступных блюд. Обратите внимание: вам нужно будет получать блюда по их типу, при этом блюд каждого типа может быть сколько угодно много.

Итак, данные будут храниться в хеш-таблице в виде «ключ-значение». В качестве ключа следует использовать тип блюд, в качестве значения — _ArrayList_ названий блюд этого типа.

Чтобы выбрать случайное блюдо из списка всех блюд типа, можно использовать метод _nextInt_ класса _Random_. С помощью этого метода вы можете сгенерировать случайное целое число, а затем взять из списка элемент с таким индексом.

Метод _nextInt_ принимает на вход один аргумент — верхнюю границу случайного числа (_bound_) и генерирует случайное число от _0_ до bound - 1. Например, если вызвать _nextInt(5)_, будет случайным образом выбрано одно из чисел: _0_, _1_, _2_, _3_ или _4_.

## Дополнительные рекомендации

* Не забывайте, что в Java можно использовать вложенные коллекции. Например, можно создать список списков или хеш-таблицу со списками. Это может пригодиться, чтобы вернуть сразу несколько вариантов комбинаций блюд для заданного набора типов.

* Для проверки, что такой тип блюд действительно существует, можно создать в классе _DinnerConstructor_ метод _checkType(String type)_. Он будет возвращать _true_ или _false_ в зависимости от того, существует ли такой тип.

Этой информации должно быть достаточно, чтобы помочь поварам и администрации накормить всех посетителей вкусными бизнес-ланчами.

Приятного программирования!